#!/bin/bash

# Optimize cpu frequencies and kernel parameters
# Written by Baonks81 (Baonks81 @ Gitlab)
# GNU GPL License, Version 2.0

# Maximum unsigned integer size in C
UINT_MAX="4294967295"

# Duration in nanoseconds of one scheduling period
SCHED_PERIOD="$((1 * 1000 * 1000))"

# How many tasks should we have at a maximum in one scheduling period
SCHED_TASKS="10"

write() {
	# Bail out if file does not exist
	[[ ! -f "$1" ]] && return 1

	# Make file writable in case it is not already
	chmod +w "$1" 2> /dev/null

	# Write the new value and bail if there's an error
	if ! echo "$2" > "$1" 2> /dev/null
	then
		echo "Failed: $1 → $2"
		return 1
	fi

	# Log the success
	echo "$1 → $2"
}

# Sync to data in the rare case a device crashes
sync

# Preliminary requirement for the following values
write /sys/kernel/debug/sched/tunable_scaling 0

# Reduce the maximum scheduling period for lower latency
write /sys/kernel/debug/sched/latency_ns "$SCHED_PERIOD"

# Schedule this ratio of tasks in the guarenteed sched period
write /sys/kernel/debug/sched/min_granularity_ns "$((SCHED_PERIOD / SCHED_TASKS))"

# Require preeptive tasks to surpass half of a sched period in vmruntime
write /sys/kernel/debug/sched/wakeup_granularity_ns "$((SCHED_PERIOD / 2))"

# Reduce the frequency of task migrations
write /sys/kernel/debug/sched/migration_cost_ns 5000000

# Improve real time latencies by reducing the scheduler migration time
write /sys/kernel/debug/sched/nr_migrate 4

write /sys/kernel/debug/sched/idle_min_granularity_ns 50000

write /sys/kernel/debug/sched/domains/cpu0/domain0/min_interval 1
write /sys/kernel/debug/sched/domains/cpu0/domain0/max_interval 4
write /sys/kernel/debug/sched/domains/cpu0/domain0/busy_factor 64
write /sys/kernel/debug/sched/domains/cpu0/domain0/imbalance_pct 125
write /sys/kernel/debug/sched/domains/cpu0/domain0/cache_nice_tries 1
write /sys/kernel/debug/sched/domains/cpu1/domain0/min_interval 1
write /sys/kernel/debug/sched/domains/cpu1/domain0/max_interval 4
write /sys/kernel/debug/sched/domains/cpu1/domain0/busy_factor 64
write /sys/kernel/debug/sched/domains/cpu1/domain0/imbalance_pct 125
write /sys/kernel/debug/sched/domains/cpu1/domain0/cache_nice_tries 1
write /sys/kernel/debug/sched/domains/cpu2/domain0/min_interval 1
write /sys/kernel/debug/sched/domains/cpu2/domain0/max_interval 4
write /sys/kernel/debug/sched/domains/cpu2/domain0/busy_factor 64
write /sys/kernel/debug/sched/domains/cpu2/domain0/imbalance_pct 125
write /sys/kernel/debug/sched/domains/cpu2/domain0/cache_nice_tries 1
write /sys/kernel/debug/sched/domains/cpu3/domain0/min_interval 1
write /sys/kernel/debug/sched/domains/cpu3/domain0/max_interval 4
write /sys/kernel/debug/sched/domains/cpu3/domain0/busy_factor 64
write /sys/kernel/debug/sched/domains/cpu3/domain0/imbalance_pct 125
write /sys/kernel/debug/sched/domains/cpu3/domain0/cache_nice_tries 1

if [[ -f "/sys/kernel/debug/sched/features" ]]
then
	# Consider scheduling tasks that are eager to run
	write /sys/kernel/debug/sched/features NEXT_BUDDY

	# Some sources report large latency spikes during large migrations
	write /sys/kernel/debug/sched/features NO_TTWU_QUEUE
fi

# Loop over each CPU in the system
for cpu in /sys/devices/system/cpu/cpu*/cpufreq
do
	# Fetch the available governors from the CPU
	avail_govs="$(cat "$cpu/scaling_available_governors")"

	# Attempt to set the governor in this order
	for governor in schedutil intelliactive interactive conservative ondemand
	do
		# Once a matching governor is found, set it and break for this CPU
		if [[ "$avail_govs" == *"$governor"* ]]
		then
			write "$cpu/scaling_governor" "$governor"
			break
		fi
	done
done

# Apply governor specific tunables for schedutil
find /sys/devices/system/cpu/ -name schedutil -type d | while IFS= read -r governor
do
	# Consider changing frequencies once per scheduling period
	write "$governor/up_rate_limit_us" 0
	write "$governor/down_rate_limit_us" 0
	write "$governor/rate_limit_us" 0

	# Jump to hispeed frequency at this load percentage
	write "$governor/hispeed_load" 85
	write "$governor/hispeed_freq" "$UINT_MAX"
done

# Apply governor specific tunables for intelliactive
find /sys/devices/system/cpu/ -name intelliactive -type d | while IFS= read -r governor
do
	# Consider changing frequencies once per scheduling period
	write "$governor/above_hispeed_delay" 20000
	write "$governor/boost" 0
	#write "$governor/boostpluse" 0
	write "$governor/boostpluse_duration" 40000

	# Jump to hispeed frequency at this load percentage
	write "$governor/go_hispeed_load" 85
	write "$governor/hispeed_freq" "$UINT_MAX"
	write "$governor/io_is_busy" 0
	write "$governor/min_sample_time" 0
	write "$governor/sampling_down_factor" 2
	write "$governor/sync_freq" 475000
	write "$governor/target_loads" 80
	write "$governor/timer_rate" 0
	write "$governor/timer_slack" 0
	write "$governor/two_phase_freq" 475000,513000,620000,860000,1000000
	write "$governor/up_threshold_any_cpu_freq" 1000000
	write "$governor/up_threshold_any_cpu_load" 75
done

# Apply governor specific tunables for interactive
find /sys/devices/system/cpu/ -name interactive -type d | while IFS= read -r governor
do
	# Consider changing frequencies once per scheduling period
	write "$governor/timer_rate" 0
	write "$governor/min_sample_time" 0

	# Jump to hispeed frequency at this load percentage
	write "$governor/go_hispeed_load" 85
	write "$governor/hispeed_freq" "$UINT_MAX"
done

# Apply governor specific tunables for conservative
find /sys/devices/system/cpu/ -name conservative -type d | while IFS= read -r governor
do
	# Consider changing frequencies once per scheduling period
	write "$governor/down_threshold" 20
	write "$governor/freq_step" 5
	write "$governor/ignore_nice_load" 0
	write "$governor/sampling_down_factor" 1
	write "$governor/sampling_rate" 30000
	write "$governor/sampling_rate_min" 20000

	# Jump to hispeed frequency at this load percentage
	write "$governor/up_threshold" 85
done

# Apply governor specific tunables for ondemand
find /sys/devices/system/cpu/ -name ondemand -type d | while IFS= read -r governor
do
	# Consider changing frequencies once per scheduling period
	write "$governor/ignore_nice_load" 0
	write "$governor/io_is_busy" 0
	write "$governor/powersave_bias" 0
	write "$governor/sampling_down_factor" 1
	write "$governor/sampling_rate" 20000

	# Jump to hispeed frequency at this load percentage
	write "$governor/up_threshold" 85
done

for queue in /sys/block/*/queue
do
	# Choose the first governor available
	avail_scheds="$(cat "$queue/scheduler")"
	for sched in cfq noop kyber bfq mq-deadline none
	do
		if [[ "$avail_scheds" == *"$sched"* ]]
		then
			write "$queue/scheduler" "$sched"
			break
		fi
	done

	# Do not use I/O as a source of randomness
	write "$queue/add_random" 0

	# Disable I/O statistics accounting
	write "$queue/iostats" 0

	# Reduce heuristic read-ahead in exchange for I/O latency
	write "$queue/read_ahead_kb" 32
done

# Always return success, even if the last write fails
exit 0
